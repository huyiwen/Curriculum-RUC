# 语义分析
## 语法制导定义
- 将文法中每个符号都赋予一些属性, 这些属性是根据语义规则得到的, 语义规则和文法相关, 这种带有属性的文法也叫作**属性文法**

### 综合属性
- 由子节点决定的属性
- 仅使用综合属性的文法是S-属性文法

### 继承属性
- 由父节点或兄弟节点决定的属性

## 语法制导翻译
- 属性的计算和传递即为语义分析, 也叫作语法制导翻译
### 依赖图
首先构造语法分析树
- 为树上每一个节点的每一个属性构造一个节点, 分别标号
- 节点$A\rightarrow B$代表了**属性$A$决定了属性$B$**
#### 良定义
如果一个属性文法的依赖图中没有环, 则是量定义的

### 抽象文法树
叶节点中没有操作符和关键字

### S-属性文法的自下而上计算
- 改造LR分析
  - 新增一个属性栈, 保存符号栈中对应文法符号的属性值
  - 在归约时同时计算属性

### L-属性文法的自上而下计算
#### L-属性文法
L中每一个产生式的每个语义规则$A\rightarrow X_1X_2\cdots X_n$的每个属性是:
- 综合属性
- 继承属性$a = X_j.att$, $a$ 依赖于$X_{i}.att, i<j$, 或者依赖于$A$的继承属性

### 翻译模式
是另一种描述语法制导翻译的形式
- 语义动作用$\{\}$括起来, 放在产生式的右部的合适位置上
- 画语法树, 将语义动作和终结符放在


## 中间语言
中间语言是语义分析器生成的语言, 逻辑清楚, 易于优化, 移植性好；它有多种形式: 后缀式、图、四元式、三元式、间接三元式
### 中间语言的形式
#### 后缀式
逆波兰表达式, 将正常表达式(中缀)转化为逆波兰表达式:
- 画出运算树
  - 叶节点为变量/数
  - 中间节点为操作符
- 中序遍历该树, 访问到哪个节点就输出
  - 先访问左子树, 再访问右子树, 最后访问根节点
#### 图
有向无环图, 节点为算符和终结符
#### 四元式
$$(操作符, 左操作数, 右操作数, 结果)$$

#### 三元式
$$(操作符, 左操作数, 右操作数)$$
- 每一个三元式有一个序号, 如果要引用另一个三元式的结果, 则将**x操作数**替换为对应序号

#### 间接三元式
可能存在相同的三元式, 则使用间接码表记录三元式的运算顺序, 使用三元式表记录每个unique三元式的内容
##### 间接码表
三元式的序号, 从第一个三元式开始执行, 算到最后一个三元式, 则得到最终结果
##### 三元式表
$$序号: 三元式$$
- 每个三元式是unique的, 和表中别的三元式不重复

### 说明语言的翻译
- ```enter(name, type, offset)```
  - 在符号表中将`name`登记在`基址+offset`的位置
- `mktable(previous)`
  - 创建一张新的符号表, 返回指向这张表的指针
  - previous为创建这张新表的过程的符号表的指针, 要登记在新表的表头信息中
- `addwidth(table, width)`
  - 在指针`table`指示的符号表标头中记录该表所有名字占用的总宽度
- `enterproc(table, name, newtable)`
  - 在指针`table`指示的符号表中为名字为`name`的过程新建一个表项, `newtable`为指向过程`name`的符号表的指针, 将其登记在`table[name]`中

#### 嵌套过程
相当于函数调用
- 每个嵌套过程都有自己的符号表, 以及自己的offset
- 在主过程中使用一个栈保存各个嵌套过程的符号表, 以及offset

**注意, 归约是倒着来的, 即$S\rightarrow AB$是最后进行的**
##### 拉链回填
一边扫描时, 不知道`S==true`时应该跳转到第几行
- 保存每一个要跳转到`S==true`的代码
- 不用数组保存, 太naive, 占用内存；使用链表:
  - 在每个要跳转到`S.true`的代码后面附加一个跳转域, 指向**上一个**要跳转到`S.true`的代码地址
  - 一旦确定了`S.true`, 则根据该跳转域将每一个要跳转代码的对应位置都填上`S。true`的代码位置

#### 记录域名

### 赋值语句的翻译
