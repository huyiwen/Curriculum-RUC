\documentclass{zpt}
\begin{document}
\section{}
一种常用的高效的检错码；

发送端在数据流的末尾添加若干个校验位, 使得生成的新数据流能够被预先规定的生成多项式整除, 接收端接收到数据流后使用生成多项式除它, 如果能除尽, 则没错, 否则出错；

要包含x+1因子；对于任意的k, 都不能整除x^k+1；

\section{}
要将数据流分成离散的帧, 解决帧数据传输的透明性问题(即怎么分辨两个帧之间的界限)。
在帧的首尾都加上01111110, 并且数据流打包成帧时只要出现011111就在其后加0, 解码时只要遇到连续的5个1就删除后面跟着的一个0。

\section{}
建立数据链路；码组或桢控制；差错控制；链路流量控制；异常状态的报告和恢复；保证编码透明传输；释放数据链路。
\section{}
使用协议, 检错码, 纠错码对传输错误的信息(数据丢失, 帧丢失, 数据出错, 帧出错)进行检测甚至纠正。
\section{}
否则将错误的数据上交到网络层, 会导致错误的结果。
\section{}
DLE STX A DLE DLE B DLE ETX
\section{}
传输数据, 进行数据打包成帧并编码, 以及误差检测和纠正。
\section{}
1) 1110
2) 可以
3) 可以
4) 不是, CRC只能检错, 还得加入确认重传机制才能实现可靠传输
\section{}
一个帧的传输时延为 512*8/64000 = 64ms
W_{max} = [2*0.27*64000/(512*8) + 1] = 9
窗口为1时, eta = 64/(270*2 + 64) = 10.59%
窗口为7时, eta = 7/(2*0.27*64000/(512*8) + 1) = 74.17%
窗口为17时, 超出限制, 因此只能先发9帧, 再发8帧, eta = (9*64+8*64)/(270*4+9*64+8*64) = 90.07%
窗口为117时, 相当于连续发送13个9帧, eta = 9*64/(270*2+64) = 95.36%

\section{}
传输时延t=1000/50000 = 20ms, W_{max} = [50000*0.27/1000] = 13
1) 每发完一帧, 要等待接收方发送的确认帧, 之后才能发送下一帧, 因此eta = 20/(20+270*2) = 3.57%
2) 一次性发送2^3=8个帧, 等待确认帧后发送下8个帧, 发送窗口=8, 接受窗口=1, 因此eta = 8*20/(20+270*2) = 28.57%
3) 一次性发送2^3/2=4个帧, 等待Ack5(4)后发送下4个帧, 发送窗口=接受窗口=4, 因此eta = 4*20/(20+270*2) = 14.29%

因此, 后退N帧协议的信道利用率最大, 当然这仅当没有误码的情况下, 如果出现较多误码, 可能选择重传协议会更好。
\end{document}