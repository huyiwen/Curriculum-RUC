[TOC]
# 传输层
网络层提供的服务是尽力交付的, 并不可靠, 需要一个额外的层来对应用屏蔽这种不可靠性并提供稳定的, **端到端**的连接。同时, 传输层提供下列功能:
- 差错检测, 网络层仅对IP分组的头部检错, TCP对数据部分进行检错
- 流量控制
- 拥塞控制
- 复用和分用

**需要注意的是, 传输层采用的协议和网络层协议是独立的, 就算传输层采用面向连接的TCP协议, 网络层也可以使用数据报方式提供无连接服务。**
## 端口和Socket
### 端口
需要通信的进程通过端口号进行标识, 就和网络层的主机通过IP地址进行标识一样；和硬件的端口不是一个概念。
- 端口号$16\mathrm{bit}$
- 端口号仅有本地意义, 即不同主机上的相同端口没有相同意义, 即不对应相同进程
#### 熟知端口号
为了方便计算机之间的通信, IANA(**互联网地址指派机构**)将一些端口号固定给一部分服务使用, 称为熟知端口号, 数值区间为$\mathbf{0\sim 1023}$。
- FTP: 21
- **远程登录TELNET**: 23
- SMTP: 25
- DNS: 53
- TFTP: 69
- **超文本传输HTTP**: 80
- SNMP: 161

#### 登记端口号
同样, 为了给一些没有熟知端口号的进程提供默认端口, IANA预留了一部分端口号作为登记端口号, 数值区间为$\mathbf{1024\sim 49151}$
#### 临时端口号/短暂端口号
最后, 客户运行的一些程序可能需要一些临时的端口, 将从$\mathbf{49152\sim 65535}$中选择
### Socket
**套接字Socket**即为某一台主机上某一个进程的标识, 相当于$$\mathbf{IP}地址:端口号$$

## UDP
在IP协议的基础上, 只添加了两项服务:
- 复用和分用
- 差错检测
### 特点
- 无连接
- 尽最大努力交付
- **面向报文**
  - 应用层传过来的数据, 加上头部直接发给网络层, 不分段
  - 网络层传上来的数据报, 去掉头部直接发给应用层
- **没有拥塞控制, 也没有流量控制**
  - 这些功能统统丢给应用层去实现
### 首部格式
UDP首部共$\mathbf{8}\mathrm{Byte}$, 仅包含$4$个域:
- **源端口号**
  - 16bit
- **目的端口号**
  - 16bit
- **长度**
  - 16bit
  - UDP数据报的长度(包括首部和数据), 单位是字节
- **校验和**
  - 16bit
  - 可选, 不计算校验和时为全$0$
### 复用和分用
#### 复用
发送方的传输层的不同的进程能够使用同一个传输层协议发送数据
#### 分用
当接收方传输层收到IP层传过来的数据报后, 可以将其分发给多个端口
### 校验
UDP对数据应用层的数据报和自身的首部和网络层的IP地址进行校验, 如果发现错误, 则**丢弃数据报**
#### 伪首部
UDP首部中不包含IP地址, 要校验IP地址, 则需要将IP地址作为伪首部添加进来, **伪首部不会向网络层/应用层传递, 仅用来校验。**伪首部包括:
- **源IP地址**
  - 4bit
- **目的IP地址**
  - 4bit
- **额外的两个字节**
  - 2bit
  - 第一个为$0$
  - 第二个为$17$
- **UDP长度**
  - 2bit
#### 校验和计算
和IP的校验和计算方法一致
- 发送端
  - 所有首部的字段都写为16bit, 校验和本身写为16个0, 然后相加
  - 得到的结果取反码, 得到校验和
- 接收端
  - 所有首部的字段都写为16bit, 相加
  - 如果结果为全$1$, 则接受；否则丢弃
### 远过程调用RPC
- 让本机调用服务器的过程(函数)
- 步骤
  - 本地调用客户存根, 即将调用程序绑定到一个进程上
  - 将需要用到的参数封装到一个消息中, 称为**列集**
  - 将消息发送给服务器
  - 服务器解封参数, 称为**散集**, 调用相应进程, 将结果反向传回来
- 缺点
  - 不能传递指针

### 实时传输协议RTP
- 目标
  - 为了应付一些**多媒体应用程序**的数据
- 步骤
  - 将音频, 视频, 文本等数据流送入RTP库
  - RTP将这些流编码进入RTP数据包
  - 数据包进入socket
  - socket的另一端接收到数据包, 形成UDP数据包, 并发送给IP直到链路

### 实时传输控制协议RTCP
- 功能
  - 可以向源端返回延迟、带宽等信息, 以便编码进程调整编码的结构和速率
  - 实现带有缓冲和抖动控制的播放

### 抖动控制
- 定义
  - 数据包到达接收端的相对时间不同, 导致接受数据延迟动态变化的情况称为抖动
- 解决方法
  - 缓冲

## TCP
UDP仅提供无连接的服务, 然而很多应用(比如超文本传输HTTP)要求稳定、可靠的连接, 并且对延迟没有那么苛求, TCP是提供这种面向连接服务的协议。
### 特点
- **面向连接**
- **每一条TCP连接仅有两个端点, 是两个Socket**
  - 不支持一对多, 多对多, 多对一, 因此不存在组播, 广播
  - 端点非主机, 也非进程, 而是套接字Socket
- **提供可靠的交付服务**
  - 无差错
  - 不重复
  - 不丢失
  - 有序
- **面相字节流**
  - 即保证接收方收到的字节流必须和发送方发的一致
  - 不关心应用一次输入了多长的报文, 反正TCP就自己干自己的
- **全双工通信**
### 报文段
TCP传送的数据单元称为**报文段**, 类似于网络层的分组和数据链路层的帧
#### 段结构
TCP首部包含固定的 $\mathbf{20}$ 字节和可变的 $4n$ 字节
- **源端口和目的端口**
  - 各2字节
- **序号**
  - 4字节
  - 序号标志着TCP段中第一个字节的编号
    - 比如一个段序号为$300$, 并包含$100B$, 那么下一个段序号为$401$
- **确认号**
  - 4字节
  - 期望收到对方的下一个报文段的序号
  - 如果确认号为$N$, 则标志前$N-1$个字节的数据都已经正确接受
- **数据偏移**
  - **4bit**
  - 单位为$\mathbf{4B}$, 相当于首部长度
- **保留字段**
  - 6bit
- **紧急位URG**
  - 为$1$时表名该报文段中包含紧急数据
  - 搭配**紧急指针**
    - 数据段中第一个字节到紧急指针所在位置的内容为紧急数据
- **确认位ACK**
  - 为$1$时表名确认号字段有效
- **推送位PSH**
  - 为$1$时强迫接收方直接上交该报文段到应用层, 而不是等缓存填满再上交
- **复位位RST**
  - 为$1$时表名TCP连接中出现严重差错, 需要重新建立连接
- **同步位SYN**
  - 为$1$是表名该报文段是一个**连接请求或连接接受报文**
  - `SYN=1,ACK=0` 表示connection request
  - `SYN=1,ACK=1` 表示connection accepted
- **终止位FIN**
  - 为$1$时代表数据发送完毕, 请求释放连接
- **窗口字段**
  - 2字节
  - **表明了发送此报文的主机缓存区的剩余量**, 单位为字节
    - 比如, 确认号为$700$, 窗口字段为$1000$, 表示缓存区还能接收$700~1699$字节的数据
- **校验和**
  - 2字节
  - 和UDP一样, 加上伪首部, 不过将$17$改为$6$
- **紧急指针**
  - 2字节
  - 紧急数据默认在数据段最前面
- **选项字段**
  - 可变长度的字段, 只有一个默认属性: 最大报文段长度
- **填充字段**
  - 如果整个首部的字节数不是4的整数倍, 则在填充字段补$0$

### 连接管理
TCP是面相连接的协议, 有三个必要的过程: 建立连接, 传输数据, 释放连接；TCP使用多种方法保证三个步骤顺利进行。

#### 建立连接:三次握手
称主动发起TCP连接的主机/Socket为客户机, 等待连接建立的Socket为服务器。假设客户机$A$要和服务器$B$建立连接
- **$A$发送请求连接段`s1(seq=x, syn=1)`**
  - 这个数据段不包含任何数据, 仅消耗一个初始的**随机**序号$x$
- **$B$收到后, 返回对`s1`的确认段`s2(seq=y, ACK=1, ack=x+1, syn=1)`**
  - 该数据段还包含了服务器为这个TCP连接预留的资源
  - 表明收到了$seq=x$的数据段
  - 服务器确认了客户机的发送功能是正常的, 现在验证客户机的接收功能
- **$A$收到确认段后, 开始发送数据, 并捎带对`s2`的确认: `s3(seq=x+1,ACK=1, ack=y+1, syn=1)`**
  - 该数据段还包含了客户机为这个TCP连接预留的资源
  - 表名收到了$seq=y$的数据段
  - 客户机确认了服务器的收发功能都正常

到这为止, TCP连接就已经成功建立, 并且是全双工的, 客户机和服务器可以互不干扰地发送和接受数据。

然而, 每次服务器接收到`SYN=1`的段, 都需要保存这个段的序号, 然后和现有连接(**正在listening的套接字**)进行比较, 并且在第二次握手时就会为TCP连接预留资源, 这给了黑客可乘之机
- **SYN泛洪攻击**
  - 黑客持续发送错误的`SYN`段, 一直占用服务器资源
  - 使用SYN coockie解决, 即接收方不保存段的序号, 而是将编号和内容一并加密发送, 等到三次握手完成后, 再运行相同的解密函数, 得到序号；在接收方解密, 并核对

#### 释放连接: 四次挥手
客户机$A$要和服务器$B$断开连接, **注意客户机可以TCP连接中的任何一方**
  - **$A$发送断开请求`d(seq=u, FIN=1)`并启动一个计时器**
    - 该报文段不包含任何数据, 但是会占用一个序号
    - 此时$A$已经停止发送数据, 而$B$还可以发送数据
  - **$B$收到`d(seq=u, FIN=1)`, 发送`d(seq=v, ACK=1, ack=u+1)`**
    - 如果$A$收到了这个报文段或者计时器超时, 那么就会释放$A\rightarrow B$的连接
  - **$B$发送断开请求`d(seq=w, FIN=1)`并启动一个计时器**
    - 此时$B$停止发送数据
  - **$A$收到`d(seq=w, FIN=1)`, 发送`d(seq=u+1, ACK=1, ack=w+1)`**
    - 如果$B$收到了这个数据包或者计时器超时, 那么就会释放$B\rightarrow A$的连接

一般来说, **第二个和第三个数据段可以放在一个段中进行发送**。

### 可靠传输
TCP使用确认、重传、序号、校验等机制保证可靠的传输:
#### 序号
每一个数据段都有其序号, 这个序号用来保证数据传输的有序性
- 保证在一个提前给定的时间$T$内, 不会有两个数据段具有相同标号
- 每过$T$, 序号重置, 重新从$0$开始
- 限制数据包在网络中的生存期, 保证网络中不会出现迟来的旧的数据包把新的数据包代替的情况
##### 禁止区域
- 假设目前时间为$t$, 周期为$T$, 那么$t\sim t+T$为序号的禁止区域, 即不能将目前发的段用禁止区域内的序号标注
- 发送速率不能过快, **否则会从下方进入禁止区域**
- 发送速率不能低于时钟频率, **否则会从左边进入禁止区域**

- Note
  - 可以保证不会被旧的重复的连接请求干扰
  - **但仍然需要保证在一定的时间间隔$T$内序号不会重复, 否则就无法区分有效的重复段和无效的重复段**
  - 断开连接时如果`DR(A)`就发送失败, 那么导致协议失败
    - 传输实体本身无法彻底解决这一问题

#### 确认
TCP连接中, 每一个数据段都会返回相应的确认。
- TCP默认使用累计确认, 即发送确认号为$x$的数据段时意味着从开始到$x-1$字节的数据都已经成功接受
- 发送端会保存每个已经发送但是还没有确认的字节, 以便稍后重发

#### 重传
两种情况下, TCP会对数据段进行重传: 超时和接收到连续的重复确认:
##### 重传计时器
发送端发出一个段后, 如果得到确认, 那么认为传输成功；如果多久没有得到确认, 认为传输失败并且重传呢？
- 记录报文段从发出到接收到其确认的时间间隔$RTT$
- 维护一个变量$SRTT$
  - 代表到达接收方的最佳估计值
- 当发送一个段后, 计时器启动
- 如果在$R$的时间后收到确认帧, 那么更新$$SRTT = \alpha SRTT + (1-\alpha) RTT$$
  - 经典情况$a=\frac{7}{8}$
- 维护一个变量 $RTTV$
  $$RTTV = \beta RTTV + (1-\beta) |SRTT - RTT|$$
  - 经典情况$\beta=\frac{3}{4}$
- 真正的重传时间间隔$$T = SRTT + 4\times RTTV$$

##### 重复确认
等待计时器超时效率比较低, 于是想办法加速通知到发送方需要重传。假设$A$给$B$发送序号为$2,8,16,32$的段, 而序号为$8$的段出错/丢失了
- $B$在接收到`seq=16`的段时, 向发送端返回`d(seq=x, ack=8, ACK=1)`的段
- $B$在接收到`seq=32`的段时, 向发送端返回`d(seq=x+1, ack=8, ACK=1)`的段

上述两个段构成了重复确认, 当发送端收到重复确认时, 就知道需要重发`seq=8`的段了。

重复确认技术在拥塞控制中也有应用。

### 流量控制
TCP的发送方和接收方都会设置缓存区(全双工), 需要管理双方的缓存区大小, 保证发送速率不能过快, 否则缓存区会溢出, 无法可靠地交付数据。**注意, 流量控制是针对发送端和接收端的, 而不是网络上的情况。**
#### 动态管理缓存
- 允许发送方和接收方互相沟通, 接收方告诉发送发为其预留的缓存区的大小, 如果没有空的缓存区, 那么发送方阻塞
  - 接收方在数据段的**窗口字段**填上目前缓存区剩余的字节数`rwnd`
  - **发送方收到后保证目前的发送窗口中已发送但还没确认的字节数小于`rwnd`, 保证不会导致溢出**
- 数据链路层的流量控制是相邻主机的, 窗口大小不能动态变化；传输层的流量控制是端到端地, 可以动态变化。


#### 窗口探测
数据段丢失时可能导致死锁, 因此接收方在一定的时间间隔下给发送方发送控制信号, 告诉发送方自己的缓存区配置

#### 延迟确认
为每一个确认帧单独发一个数据段会降低带宽利用率, 因为确认数据段中不包含有效数据。因此, 将确认段和窗口更新段的发送延迟50ms, 等等有没有新的数据涌入, 可以一起处理, 进行**捎带确认**。

#### 低能窗口Silly window
应用程序从窗口中一次只读取一个字节, 每读取一个字节, 接收端就要向发送端重新发送一个tcp段说明窗口的剩余大小
- 禁止接收端发送窗口大小为1的更新段, 强制接收端等一阵再发送

### 拥塞控制
当网络上有过多的数据时, 可能导致路由器的缓存区队列溢出、链路过载等等问题, 这就是**拥塞**。然而, 发送方和接收方两个端点对网络上的情况一无所知 (传输层做到了透明传输), 它们只能感知到传输时延的变化。需要使用一些机制来避免/缓解拥塞, 以保证网络的高效运转。**注意, 拥塞控制不同于流量控制, 是针对整个网络的, 而非两个端点。**

具体而言, TCP协议要求发送方维护两个窗口:
- **接受窗口`rwnd`**
  - 在流量控制中介绍过
- **拥塞窗口`cwnd`**
  - 发送方根据自己估算的网络拥塞程度而设定的窗口, 网络没有拥塞时, 可以调大该窗口；一旦拥塞, 就将该窗口减小。

最终发送方的**发送窗口`wnd`** 为
$$wnd = \min(rwnd, cwnd)$$

那么, 如何维护拥塞窗口的值呢？有四个算法:
#### 慢开始
为了让发送速率快一点达到高效的速率:
- 在TCP连接建立好后, `cwnd`最初为$1$
- 发送方每收到一个确认报文段, 则将`cwnd+1`
  - **每经过一个RTT(往返时延), 拥塞窗口大小翻倍**
  - `cwnd`的变化为$2\rightarrow4\rightarrow8\rightarrow\cdots$
- 当`cwnd`增大到一个阈值`ssthresh`时, 即`cwnd >= ssthresh`时, 令`cwnd=ssthresh`, 并切换为**拥塞避免算法**

#### 拥塞避免
- **加法增大**
  - 发送方的`cwnd`每经过一个$RTT$则`cwnd+1`, 而非翻倍
- **乘法减小**
  - 当检测到丢包(表示网络拥塞) 时, 设置`ssthresh=cwnd/2`, 并且`cwnd`从$1$重新开始

#### 快重传
即利用[重复确认](#重复确认)技术, 一旦发送方收到**连续$3$个**重复确认时, 则认为该段丢失；
#### 快恢复
在发生拥塞时, 设置`ssthresh = cwnd/2`, 然后令`cwnd = ssthresh`, 开始执行**拥塞避免算法**


### 崩溃恢复
- 崩溃恢复无法对上层透明, 只能靠上一层(应用层)完成


### 调整发送速率
- **AIMD控制法则**
  - 两个用户, 使用**加法递增, 乘法递减**自身的带宽, 最终会收敛在最公平且最有效的点

### 无线问题
- 丢包不意味着拥塞, 更可能是因为传输出错
