[TOC]
## 功能
加强物理层传输比特流的功能, 为网络层提供一条**无差错**的链路
- 为网络层提供三个服务:
  - 无确认无连接服务
    - 发帧, 完成
    - 适用于误码率低的线路, 大部分局域网(以太网)
  - 有确认无连接服务
    - 发帧, 确认, 无确认重发
    - 适用于不可靠的信道, 比如无线网
  - 有确认有连接服务
    - 连接, 发帧, 释放
    - 有连接就一定要有确认, **不存在无确认有连接的服务**
- 链路管理
  - 维护链路创建, 释放等过程
- 成帧
- 流量控制
  - 控制对象是相邻两个节点之间链路上的流量, 和传输层端到端的流量控制不同
- 差错控制

## 成帧
- 帧时数据链路层的基本数据单元, 即将网络层的分组包装起来, 加上头部和**尾部(为了在实际接收到的比特流中区分出帧的概念)**

### 字符计数法
- 在帧头用一个域表示整个帧的字符个数
- 一旦这个计数自身出错, 所有随后的帧都会出错
### 带字符填充的首尾字符定界法
- 起始字符`DLE STX`, 结束字符`DLE ETX`, 数据中遇到标志字符(`DLE`)时插入转义字符`DLE`在其前面
- 只能传送ASCII
### 零比特填充的首尾字符定界法
- 在帧的起始和结束都用一个特殊的串`01111110`标志, 数据中遇到`011111`时就在后面填充`0`, 形成`0111110`
- 接收方做相反操作, 即将所有`0111110`转为`011111`

## 差错控制
实际在链路中传播数据, 肯定是会出错的, 那么如何纠正错误呢？ 一种方式是设计纠错码, 接收端可以根据纠错码对数据纠错；另一种方式是设计检错码, 接收端如果检查到错误就请求发送端重新发送这个帧

### 基本概念
#### 码字
- 一个帧包含$m$个数据位, $r$个校验位(冗余位), $m+r=n$
- **要纠错单比特误码(只错一位), 则需要将每一种可能的错误都编码, 对于$n=m+r$位的编码, 其一共有$2^n = 2^{m+r}$个可用码字, $2^m$个有效码字, 每一个有效码字会对应$n+1$种不同的出错情况(还有一种是不出错)**, 因此有$$\begin{aligned}
  (n+1)2^m&\le 2^{m+r}\\
  \implies n+1 &= m+r+1 \le 2^r
\end{aligned}$$
#### 海明距离
两个码字中不同比特的个数
- **编码的海明距离为任意两个码字的海明距离的最小值**
- 要检测$d$比特错, 那么码字的海明距离为$d+1$
- 要纠正$d$比特错, 那么码字的海明距离为$2d+1$

### 检错码
核心思想是[冗余编码](Term.md#冗余编码)
#### 奇偶校验码
- 在数据后添加一个奇偶位
  - 奇校验: 补 $1/0$ 使得整个编码的$1$个数为奇数
  - 偶校验: 补 $1/0$ 使得整个编码的$1$个数为偶数

- **只能检测出奇数个错误, 因为错两个则奇偶位不变**
#### 循环冗余校验码（CRC码）
- 发送方和接收方预先规定一个$r$**阶的生成多项式**$G(x)$
  - 生成多项式是给定的, 要求是最高阶 $x^r$ 和最低阶 $x^0$ 必须为$1$, 因此该生成多项式**对应的二进制码共$r+1$位**
  - $G(x) = x^3+x^2+1\implies G(x) = 1101$
  - 生成多项式要包含$x+1$因子
  - 对于$\forall k\in N$, 生成多项式**不能整除**$x^k + 1$
- 给定一个$m\mathrm{bit}$的数据, 为其生成一个$r\mathrm{bit}$的校验位, 形成$m+r\mathrm{bit}$的数据对应的多项式能够被$G(x)$整除
- 接收端接收到数据流后使用生成多项式除它, 如果能除尽, 则没错, 否则出错
##### 生成
假设原信息码为$M(x)$, 有$|M(x)| = m$, $G(x)$为$r$阶(**对应的比特数共$r+1$位**)
- **加0**
  - 在 $M(x)$ 后补 $r$ 个$0$, 得到$M(x)'$
- **模2除**
  - 用$M(x)'$[模2除](Term.md#模2除)以$G(x)$, 得到 $r$ 位的余数$R(x)$, 这个余数就是**CRC冗余码**
- 最终生成的结果, 即**CRC校验码**为$M(x)' + R(x)$, 它可以被$G(x)$整除
##### 校验
- 若CRC码可以整除生成多项式，则没有错
- *如果有余数，则补0继续除, 直到余数为$101$, 如果一共补了$n$次0, 则第$n+1$位出错*

##### 特征
- 只能无差错接受, 要做到“可靠”(**发送什么接到什么**), 需要添加确认和重传机制

### 纠错码
#### 海明校验码
- **确定海明码的位数**
  - 假设有$m$位有效信息, 并要设计$k$位校验位, 那么应该满足(基本原理Section有推导):$$n+1 = m+k+1\le 2^k$$
  - 形成的海明码为$H_nH_{n-1}\cdots H_1$
  - 校验位为$P_kP_{k-1}\cdots P_1$
  - 数据位为$D_mD_{m-1}\cdots D_1$
- **确定校验位在海明码中的分布**
  - $P_i$位于$H_{2^{i-1}}$, 即$H_{2^{i-1}} = P_i$
  - $H_1 = P_1, H_2 = P_2, H_4 = P_3 \dots$
- **分组校验**
  - 对于$H_{2^{i-1}} = P_i$, 其校验对象为所有$H_j$, $j$的二进制表示中第$i$位为$1$
    - $P_1$就要校验$H_3(3 = 11), H_5(5 = 101),H_7(7 = 1001)\dots$
    - $P_2$就要校验$H_3(3 = 11), H_{6}(10 = 110), H_{7}(7 = 111)\dots$
- **计算校验位**
  - $P_i = H_1^i\oplus H_2^i\oplus H_3^i\cdots \oplus H_l^i$
    - $H_j^i$即为分给$P_i$的所有校验对象
    - $\oplus$为异或, **连续的异或当有奇数个$1$时结果为$1$, 否则为$0$**
- **纠错**
  - 计算每一个校验位和其校验对象的异或, 形成方程$$\begin{aligned}
    S_1 &= P_1\oplus H_3\oplus H_5\cdots \oplus H_l^1\\
    S_2 &= P_2\oplus H_3\oplus H_{6}\cdots \oplus H_l^2\\
    \cdots\\
    S_k &= P_k\oplus H_{2^{k-1} + 1}\cdots \oplus H_l^k\\
  \end{aligned}$$
  - 若所有的$S_kS_{k-1}\cdots S_1 = 00\cdots 0$ 则说明没错。
  - 若不全为$0$，则$S_kS_{k-1}\cdots S_1$表示的数位是出错位置，将这个位置的数取反即可

- 以上的海明校验码**只能纠错1位**，但可以改进成纠错2位的
  - 新增一位$P_0$对所有除了他自己外的信息做偶校验
  - 检查时对包括$P_0$在内的所有信息做偶校验

    |P|C|是否出错|
    |:-:|:-:|:-:|
    |0|0|没错|
    |0|$\ne 0$|偶数个位出错|
    |1|0|P出错|
    |1|$\ne 0$|奇数个位出错|
  - $2^{r-1} \ge k+r$

## 流量控制
控制链路上的帧的发送速率, 让接收方有足够的缓冲空间接受每一个帧, 通常的做法是让接收方给发送方反馈, 并控制发送速率。那么发送方收到反馈后是连续发好几个新帧, 还是只发一个呢？这就涉及到具体的协议细节。
### 协议
#### 自动重传请求ARQ协议
- **发送方在发下一个帧之前等待一个肯定确认**
  - 发送方发送完一个数据帧后, 启动一个超时计时器, 如果到了超时计时器设定的重传时间还没有收到任何确认帧, 则重新传输上一个数据帧
  - 每一个数据帧都要带上不同的发送序号, 表明是哪一帧, 如果接收端已经接受过当前序号的帧, 则证明出现了重复帧, 需要将重复帧丢弃
  - 每一个响应帧都要带上对应帧的发送序号, 表明确认收到了这个帧, 可以使用[捎带技术](Term.md#捎带技术)
    - 也可以表名接收方正确接受的帧的最大编号
    - 对于停等协议, **由于每发送一个数据帧就等待, 那么用一个比特来编号就够了, 数据帧的发送序号以01交替的方式出现在数据帧中**
  - **重传时间**
    - $$t_{out} = t_p + t_{pr} + t_a + t_p + t_{pr} \approx 2t_p$$
      - $t_p$为帧在信道中传播时间, $t_{pr}$为接收端处理数据帧时间(CRC校验), $t_a$为接收端发送确认帧的传输时间
#### 滑动窗口
##### 发送窗口
  - 发送方一直维护着一组**连续的允许发送的帧的序号**, 称为发送窗口
  - 得到一个确认帧, 发送窗口就向前移动一个帧的位置, 当窗口内所有帧都没有得到确认, 则停止发送
##### 接受窗口
  - 接收方同样维护着一组**允许接受的帧的序号**, 称为接受窗口, 只有落在接受窗口之中的帧才会被正常接收, 其余的全部丢弃
  - 每收到一个符合条件的数据帧, 就返回这个帧的确认帧, 并且接受窗口向前移动一个单位

#### 停止-等待协议
- 发送方发送一个帧, 必须得到这个帧的确认后, 再发送下一个帧；如果一直没有得到确认而计时器超时, 则重传
  - 接收方如果检查数据出错, 也不会回复确认帧
- 相当于$发送窗口=1, 接受窗口=1$
- 信道利用率很低
#### 后退N帧协议GBN
- 发送方可以连续发送多个帧, 但**接收方只会按顺序接受帧**, 如果第$i$个帧出错而接收到序号为$i+1\cdots N$的帧, 则统统丢弃, 并要求发送方重传第$i$帧
  - 可以积攒好几个确认帧一并发出, 或者使用捎带确认
  - 为了保证能够成功区分新帧和旧帧, 发送窗口的大小满足$$1\le W_T\le 2^n - 1$$
    - $n$为帧编号的比特数
- 相当于$发送窗口>1, 接受窗口=1$
#### 选择重传协议SR
- 只重传出错的帧而非出错帧后所有帧
- 相当于$发送窗口>1, 接受窗口>1$, 用大于$1$的接受窗口接受不连续但仍然在接受范围内的帧
- 接收方如果收到一个出错的帧, 则会返回带有出错帧序号的NAK, 让发送方重发该帧；同时, 如果发送方计时器超时, 也会重发缓冲区内所有帧
- 为了保证能够区分新帧和旧帧, 发送窗口和接受窗口大小需要满足$$W_T + W_R \le 2^n,\quad W_R\le 2^{n-1}$$
  - 其中$n$为帧编号的比特数
  - 一般来讲, $W_T = W_R$

### 信道效率
信道的效率又称信道利用率, 有
- 若滑动窗口的发送窗口为$W$, 则信道利用率$$\eta \le \frac{W}{1+\frac{2BD}{L}}$$
  - $B$为信道带宽
  - $D$为单向传播时延
  - $L$为数据帧的长度(bit)
  - $1+\frac{2BD}{L}$理解为能发送的最多帧数
  - $\le$因为**误码率高时需要重传很多帧**
- $$达到最大的信道利用率\Leftrightarrow 第一个帧的确认返回时窗口中所有帧已经发送完毕$$
### 常见的数据链路层协议
#### 面向字符协议
- 点到点协议 PPP
#### 面向比特协议
- SDLC
- HDLC