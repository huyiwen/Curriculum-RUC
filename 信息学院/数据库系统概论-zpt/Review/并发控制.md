[TOC]
# 并发控制
## 数据不一致性
- 丢失修改
  - 两个事务$T_1$和$T_2$度如同一个数据并修改, 后提交的事务的结果破坏了先提交的事务的结果
- 不可重复读
  - $T_1$读取某一个数据后, $T_2$对其进行了修改, 导致$T_1$再一次读取同样数据失败
  - $T_1$按一些条件读取某些数据后, $T_2$对其进行了删除, 导致$T_1$再一次筛选时发现数据消失
  - $T_1$按一些条件读取某些数据后, $T_2$添加了符合条件的新的数据, 导致$T_1$再一次筛选时发现数据变多
- 读脏数据
  - $T_1$对某些数据修改后$T_2$读取了该数据, 之后$T_1$由于某些原因被撤销, 导致$T_2$读取的数据成为错误数据

## 并发控制方法
### 封锁
- 类型:
  - 排它锁(**写锁/X锁**)
    - 事务$T$对数据对象$A$加上X锁, 则只允许$T$读取和修改A, 其他任何事物都不能对A**加锁(读取/修改)**
  - 共享锁(**读锁/S锁**)
    - 事务$T$对数据对象$A$加上S锁, 则**允许$T$读取A, 但不允许$T$修改A, 其他事务只能再对A加S锁, 不能加X锁, 直到$T$释放A上的S锁为止**
    - 事务$T$可以对$A$加$X$锁

- **封锁协议**
  - **一级封锁协议**
    - 事务$T$对$R$修改时必须先对其加$X$锁, 直到$T$**事务结束后**释放
    - **保证不会丢失修改, 但因为不涉及$S$锁, 所以无法解决不可重复读和读脏数据**
  - **二级封锁协议**
    - 在一级封锁协议的基础上, 事务$T$在读取数据$R$前必须先对其加$S$锁, **读完后**即可释放锁
    - **保证不会丢失修改, 不会读脏数据, 但无法解决不可重复读**
  - **三级封锁协议**
    - 在一级封锁协议的基础上, 事务$T$在读取数据$R$前必须先对其加$S$锁, 在$T$**事务结束后**才能释放
    - **保证不会丢失修改, 不会读脏数据, 可以重复读**

- 活锁和死锁
  - 活锁
    - 多个事务请求封锁$A$, 导致某个事物一直处于阻塞态无法执行
    - **解决办法: 先来先服务**
      - 按照请求顺序排队, 依次出队然后获得锁
  - 死锁
    - $T_1$封锁了$R_1$, $T_2$封锁了$R_2$, $T_1$又请求封锁$R_2$, 由于$R_2$已经上锁因此被阻塞, $T_2$又申请封锁$R_1$, 同理也一直阻塞, 两者循环等待
    - **预防死锁**
      - **一次封锁法:** 每个事务必须一次将所有要使用的数据全部加锁, 否则就不能继续执行
      - **顺序封锁法:** 预先对数据对象规定一个封锁顺序, 所有事务都按照这个顺序对数据加锁
        - 成本高昂
        - 难以适应动态变化
    - **诊断死锁**
      - 超时法
        - 如果一个事务的等待时间超过了规定的时限, 就认为发生了死锁
      - 等待图法
        - 以正在运行的事务为节点, 等待为边, 画有向图, 如果$T_1$等待$T_2$, 则有$e(T_1,T_2)\in E$, 并发控制系统周期性地更新等待图并检查是否有回路
    - **解除死锁**
      - **选择处理代价最小的事务, 将其撤销, 释放次失误持有的所有的锁**

## 并发调度的可串行性
### 可串行化调度
- 定义: 多个事务的并发执行是正确的$\Leftrightarrow$其结果按**某一次序串行**地执行这些事务的结果相同
- **一个并发调度是正确的$\Leftrightarrow$其是可串行化的**

### 冲突操作
- 不同的事务对同一个数据的读写操作和写写操作
- **冲突操作的顺序不能改变, 否则会引起数据库错误**
- **冲突可串行化**
  - 一个调度$S_c$在保证冲突操作顺序不变的情况下, 通过交换两个事务不冲突操作的顺序得到另一个调度$S_c'$, 如果$S_c'$是可串行化的, **那么$S_c$是冲突可串行化的调度, 并且一定是可串行化的**
- 可串行化调度不一定是冲突可串行化调度
  - 有一个新的事务去收尾, $e.g.\quad W_1(A)W_2(A)W_3(A) == W_2(A)W_1(A)W_3(A)$

### 两段锁协议(2PL)
- 事务的封锁分为两个阶段
  - **第一阶段获得封锁, 不能释放任何锁**
  - **第二阶段释放封锁, 不能申请任何锁**
- 如果并发执行的所有事务均遵守两段锁协议, 那么这些事务的任何并发调度策略都是可串行化的( **充分条件** )
- **遵循两段锁协议的调度可能发生死锁**

### 封锁粒度
- 封锁对象的大小称为封锁粒度
  - 逻辑单元
    - 属性值, 属性集合, 元组, 关系, 索引项, 整个索引乃至数据库
  - 物理单元
    - 页, 物理记录等
- 封锁的粒度越大, 并发度越低, 开销越小；粒度越小, 并发度越高, 开销越高；
- **多粒度封锁**
  - 系统同时支持多种粒度的封锁
  - 多粒度树
    - 根节点是整个数据库
    - 叶节点是最小的数据粒度
    - **每一个节点仅有一个父节点**
    - **对一个节点加锁意味着对其后裔节点加同样类型的锁**
      - 显式封锁: 响应事务的要求, 直接对相应数据对象加锁
      - 隐式封锁: 该数据对象没有被独立加锁, 而是由于其上级节点加锁而使自己加锁
    - **系统检查封锁冲突时要检查当前节点的上级节点和下级节点, 确保所有数据对象上都没有不相容锁, 否则等待**
#### 意向锁
  - 如果对一个节点加意向锁, 说明该节点的**下层节点正在被显示加锁**, 对任何一个节点加锁时, 必须先对它的上层节点加意向锁
  - **理解**
    - **一种“懒惰”的加锁机制**, 尽可能地让后代去判断到底是否冲突
