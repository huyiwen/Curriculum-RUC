\documentclass[UTF8]{ctexart}
\usepackage{dirtree}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage[a4paper]{geometry} 
\usepackage{amsmath,amsthm,mathtools}
\usepackage{mathtools}
\usepackage{diagbox}
\usepackage{multirow,makecell}
\usepackage{url}
\newcommand{\refe}[1]{Eq.\ref{#1}}
\newtheorem{theory}{Theory}[section]
\title{作业4}
\author{张配天-2018202180}
\date{\today}
\geometry{bottom=2cm,left=2cm,right=2cm}
\begin{document}
\maketitle
    \section{6.5}
    \subsection{a}
    \begin{table}[htb]
    \centering
        \begin{tabular}{cccc}
            \hline
            R1&R2&R3&R4\\
            \hline
            1&0&2&1\\
            \hline
        \end{tabular}
    \end{table}
    \subsection{b}
    \begin{table}[htb]
        \centering
        \begin{tabular}{cccc}
            \hline
            R1&R2&R3&R4\\
            \hline
            3&2&0&0\\
            0&1&1&2\\
            2&1&0&0\\
            0&0&1&0\\
            2&1&1&1\\
            \hline
        \end{tabular}
    \end{table}
    \subsection{c}
    是安全状态。
    \textbf{P1-P2-P3-P4}
    \begin{table}[htb]
        \centering
        \begin{tabular}{ccccc}
            \hline
            Process&R1&R2&R3&R4\\
            \hline
            P1&9&3&5&4\\
            P2&9&4&5&4\\
            P3&10&5&6&4\\
            P4&11&6&6&5\\
            P5&11&6&6&5\\
            \hline
        \end{tabular}
    \end{table}
    \subsection{d}
    是正确的。因为P1只需要3个R1资源，若再加一个则需要4个R1资源，而可用资源数为6个R1，所以可以赋予资源。
    \section{6.6}
    \subsection{a}
    三个进程并发执行，则当每个进程运行到前两句后，6个资源分别被3个进程占有，则每个进程都被阻塞在第三行语句，
    引发死锁。
    \subsection{b}
    考虑把P1中\emph{get(B)}和\emph{get(E)}互换位置。\par
    则同样考虑并行情况：
    P0申请到A资源后P1申请到B资源，P2申请到C资源，由此P0倍阻塞，
    P1继续申请得到D资源，P2申请F资源，P1申请E资源，P2被阻塞，之后P1正常运行，
    运行结束后归还资源，P2得以运行，最后P0运行。

    其他的运行情况也是类似的。
    \section{6.7}
    因为$i+o\le max$，则考虑$i==max$时：
    \begin{enumerate}[1.]
        \item I进程仍在等待向Input Buff中写入信息
        \item P进程在等待空间，向Output Buff中写入信息
        \item O进程在等待从OutputBuff中读取信息
    \end{enumerate}
    这样就造成了死锁。

    \section{6.14}
    \subsection{a}
    会造成死锁。考虑foo进程执行到semWait(S)后bar进程执行SemWait(R)，
    则此时两个互斥信号量都变为0，无论是semWait(R)还是semWait(S)均会被阻塞，进而造成死锁。
    \subsection{b}
    不会造成饿死。\emph{若进程得以执行}，由于两个进程均有semSignal(S)和semSignal(R)，则当任一个进程运行结束后
    均会使R和S各加1，从而唤醒正在阻塞中的另一个进程。
\end{document}
