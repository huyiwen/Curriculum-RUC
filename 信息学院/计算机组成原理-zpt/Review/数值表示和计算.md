<h1>数据的表示和计算</h1>


[toc]

## 各种码

### 原码

- 最高一位是**符号位**
- 注意一下范围，极限范围那边需要减去1，因为正负各有一个正零与负零。
- 符号位0代表正数，1代表负数

### 补码

- 方便运算
- 以8位举例，范围为$-2^7\sim2^7-1$
- 原码在转换为补码
  - 若是正数，则相同
  - 若是负数，则将数位取反，然后加1
- 补码转换为原码
  - 若是正数，则相同
  - 若是负数，则将数位取反，然后加1
    - **减1后取反和取反加1是等价的**
  - **说白了就跟原码转补码相同**

### BCD码

- 课件里主要说的是8421码，用4位表示一个十进制数
- 由于4位表示，所以会有6个数的冗余。因此当值超过最大的十进制数9时，需要加6。即所有的数需要小于等于$1001$，否则加上$0110$。

### 浮点数

- 一般表示：$N=M\cdot r^E$，有点类似于科学计数法
  - $N$：浮点数
  - $M$：尾数, **纯小数即$0.x$**, 自带符号位
  - $E$：阶数, 纯整数, 自带符号位
  - $r$：底数，一般为$2$
- 计算机中浮点数的构成（$4$个部分）：
  - 阶码符号位（$Es$，$1$位）
  - 尾数符号位（$Ms$，$1$位）
  - 阶码（$E$，$n$位）
  - 尾数（$M$，$m$位）
#### 规格化
- 规格化作用的是尾数，相应的尾数大小改变也需要去调整阶数大小
- 原码规格化后，尾数最高位一定是1
- 补码规格化后，尾数最高位一定与尾数符号位相反
- 尾数左移一位, 阶码减1
- **如果给定了尾数的位数限制, 注意别超了, 多的就舍去**
#### 表示范围
- **阶数**, 默认数值$n$位
  - 使用原码表示
  $$E\in[-2^n+1, 2^n-1]$$
  - 使用补码表示
  $$E\in [-2^n ,2^n-1]$$
- **尾数**, 默认数值$m$位
  - 使用原码表示
  $$M\in [-1+2^{-m}, 1-2^{-m}]$$
  - 使用补码表示
  $$M\in [-1, 1-2^{-m}]$$
- **未规格化**
  - **绝对值最大的正数**
     $$x=M_2*2^{E_2}$$
  - **绝对值最小的正数**
     $$x=2^{-m}*2^{E_1}$$
  - **绝对值最大的负数**
     $$x=M_1*2^{E_2}$$
  - **绝对值最小的负数**
     $$x=-2^{-m}*2^{E_1}$$
- **规格化**
  - **绝对值最大的正数**
     $$x=M_2*2^{E_2}$$
  - **绝对值最小的正数**
     $$x=2^{-1}*2^{E_1}$$
  - **绝对值最大的负数**
    $$x=M_1*2^{E_2}$$
  - **绝对值最小的负数**
     - 尾数为原码
    $$x=-(2^{-1})*2^{E_2}$$
    - 尾数为补码
    $$x=-(2^{-1}+2^{-m})*2^{E_1}$$
### 奇偶校验码

- 都是添加一位，使得整个码中，$1$的个数为奇数或是偶数
- 添加位可以是最高位，也可以是最低位
- 只能发现**奇数个位错,不能纠正错误**
- 奇校验
  - 添加0或1，使得1的个数为奇数
- 偶校验
  - 添加0或1，使得1的个数为偶数

### 海明校验码

- 多添加好几个校验位，以达到**可以纠错**的能力
- 若校验位个数为$r$，信息位的个数为$k$
  - **要满足关系：$2^r\ge k+r+1$**
  - 因为$r$个校验位可以表示$2^r$个状态，减去一个“没有错误状态”，还剩$2^r-1$个，所以要做到纠错，得保证其大于$k$
- 总的海明校验码一共有$k+r$位，从高到低用$H_{k+r},H_{k+r-1},\ldots,H_1$来表示。
- 海明码中每一个数位对应的二进制表达为$b_mb_{m-1}\cdots b_0$, **数位编号从$0\cdots 01$开始**, 不存在$0\cdots 0$
  - 在$2^i$位($0,1,2,4\cdots$)，存放校验位$P_i$，其余位置按顺序放信息位$D_i$, 因此$ID(P_i) = b_m\cdots b_0$中只有一位是$1$, 记作$b_i$
  - $P_i$的计算方式为所有$b_i=1$的**信息位**做**异或**
    - **连续的异或当有奇数个$1$时结果为$1$, 否则为$0$**
- **检查方式：**
  - 通常以$C$来表示检查码
  - 检查码$C_i$的计算方式为所有$b_i=1$的**信息位**和**第$2^i$个校验位一起**做**异或**
  - 若所有的$C$都为0，则说明没错。若不为$0$，则$C$表示的数位出错位置，将其取反即可
- 以上的海明校验码**只能纠错1位**，但可以改进成纠错2位的
  - 新增一位$P_0$对所有除了他自己外的信息做偶校验
  - 检查时对包括$P_0$在内的所有信息做偶校验

    |P|C|是否出错|
    |:-:|:-:|:-:|
    |0|0|没错|
    |0|$\ne 0$|偶数个位出错|
    |1|0|P出错|
    |1|$\ne 0$|奇数个位出错|
  - $2^{r-1} \ge k+r$

### 循环冗余校验码（CRC码）

- 基本思想：**在$k$位信息码后面再拼接$r$位的校验码**，整个编码长度为$N$位。因此CRC码又称$(N,K)$码
- CRC码需要一个生成多项式，这个多项式不能乱搞，有特点要求，但题目会给。如$G(x)=x^3+x^2+1$，该生成多项式对应的二进制码为$1101$, **多项式的位数为$r+1$**
- 生成CRC码的步骤：
  - 原信息码为$M(x)$, $r=n-k=|G(x)|-1$
  - 除法：$M(x)*2^r$**模2除**$G(x)$, 生成商和余数（$r$位）
  - 生成：**原信息码$+$余数就是CRC码**
- 校验步骤：
  - 若CRC码除以生成多项式可以整除，则没有错
  - 如果有余数，则补0继续除, 直到余数为$101$, 如果一共补了$n$次0, 则第$n+1$位出错

## 原码/补码各种计算
### 注意点
- **所有补码运算结果都是补码, 需要转换成原码**
- **$n$为乘数的数值位数**
### 原码/补码左右移
- **左移**
  - 相当于$\times 2$
  - 空位补$0$
  - **如果符号位发生改变($0\rightarrow 1$/$1\rightarrow 0$), 则发生溢出**
- **右移**
  - 相当于$\div 2$
  - **空位补符号位**
### 原码/补码加减法

- 加法非常简单，但要注意溢出
- 减法要取负转变为加法
- 溢出分为两种：
  - 正数$+$正数导致正溢出，溢出后符号位为负
  - 负数$+$负数导致负溢出，溢出后符号位为正
- 单符号位不能处理溢出，双符号位可以处理溢出

### 原码一位乘法

- 符号位不参与计算，需要单独计算
  - 计算方式为$\oplus$（**异或，相同为0，不同为1**）
- 对于一个n位的数（不包括符号位）
  - 取双符号位
  - 需要算出$|x|$和$|y|$（原码）
  - 乘法次数为$n$次
  - 移位次数为$n$次
  - 移位方向为向右

### 补码一位乘法
#### 修正法
- 步骤
  - **被乘数连同两位符号位一起参加运算**, 乘数**仅数值位**参加运算
  - 如果乘数>0, 即$y_0>0$, 则直接的结果
  - 如果乘数<0, 即$y+0<0$, 则在结果后面加$[-x]\times y_0$
- $n$次累加
- $n$次移位
#### Booth法
- **被乘数联通两位符号位**参与运算, 乘数**一位符号位**参加运算
- 要用两位来判断到底是加啥玩意儿，因此**刚开始需要在乘数末尾添加一个0**
  |后一位减前一位|操作|
  |:-:|:-:|
  |0|加0，右移一位|
  |1|加$[x]_{补}$，右移一位|
  |-1|加$[-x]_{补}$，右移一位|
- **乘法次数为$n+1$次**
- **移位次数为$n$次, 最后加完不移位**
- 移位方向为向右

### 原码两位乘法
- **符号位不参与运算**
- 如果**乘数数值位**为**奇数**
  - 在乘数**末尾**补一个0
  - **最后一次移位只移一位**
- 如果**乘数数值位**为**偶数**, 则正常计算
- 在乘数末尾补一个进位$C=0$
- 每次部分积右移两位
- **进行$\lceil\frac{n}{2}\rceil$次乘法, $\lceil\frac{n}{2}\rceil$次移位**
- 最后要考虑符号
### 补码两位乘法
- **被乘数取$3$位符号位参与运算, 乘数$1$位符号位**
- 如果**乘数数值位**为奇数, 正常计算
- 如果**乘数数值位**为偶数
  - 在乘数末尾补一个$0$
- 在乘数末尾补一个附加位$Y_{i+1}=0$
- 每次部分积右移两位, **最后一次仅右移一位**
- **进行$\lceil\frac{n+1}{2}\rceil$次乘法, $\lceil\frac{n+1}{2}\rceil$次移位**
### 原码恢复余数除法
- 被除数$2$符号位参与运算, 除数符号位不参与运算
- 最后一次不移位
  
### 原码加减交替除法
- 符号位不参与运算
  - 计算方式为$\oplus$（**异或，相同为0，不同为1**）
- 对于一个n位的数（不包括符号位）
  - **取$1$位符号**
  - 加减次数为$n+1$或者$n+2$（**若最后余数为负，则需要加上$|y|$来得到正确的余数，所以多一次**）
  - 移位次数为$n$次
  - 移位方向为向左，商补0
  - 结果里商和余数都为原码
- 计算步骤：
  - 初始时，商那边要写成0.0000（**0的数量跟位数有关**）
  - 任何情况下**第一步都是减去被除数，即加上$[-|y|]_补$**
  - 部分余数、商以及该步加减规则：
    - 如果部分余数为负，则商上0，这步就加
    - 如果部分余数为正，则商上1，这步就减
    - 都是**商上0就加，商上1就减**

### 补码加减交替除法

- 符号位参与运算
- 对于一个n位的数（不包括符号位）
  - **取$2$位符号**
  - 需要算出$[x]_补$、$[y]_补$和$[-y]_补$
  - 加减次数为$n+1$次
  - 移位次数为$n$次
  - 移位方向为向左，商补0
  - 结果中商和余数都为补码
  - **采用末位恒置1法**
- 计算步骤：
  - 初始时，商那边要写成0.0000（**0的数量跟位数有关**）
  - 第一步，若被除数、除数同号，则减除数；异号，则加除数。（**同号减，异号加**）
  - 部分余数、商以及该步加减规则：
    - 余数、除数同号，则商上1，这步就减
    - 余数、除数异号，则商上0，这步就加
    - **同号减（1代表负数），异号加（0代表正数）；商上0就加，商上1就减**，总结起来，还是**同号减（1代表负数），异号加（0代表正数）** 这句话最合适
  - **最后一位商恒置1**

### 总结
- **$Y$中数值位记为$n$**
- **原码操作中所有$[x]$都是$[|x|]$**
- **每个运算周期都是求和后左/右移**
- **加:**$+[x]$
- **减:**$+[-x]$
#### 乘法
- 部分和位数永远和$X$一致
- 两位乘法中补零的规则:**要保证参与运算的乘数部分永远是偶数位, 而原码没有符号位, 因此数值位必须是偶数；补码一位符号, 因此数值位必须为奇数。**
- **附加位, 补的零不算在结果里!**

|运算|$X$符号|$Y$符号|补$0$|附加位|运算规则|累加|移位|重点|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|原码一位乘法|$2$|$0$|||$Y_{i}$|$n$|$n$||
|原码两位乘法|$2$|$0$|乘数位为**奇数**,末尾补$0$|进位$C$默认为$0$|$Y_{i-1},Y_{i},C$|$\lceil\frac{n}{2}\rceil$|$\lceil\frac{n}{2}\rceil$||
|补码一位乘法|$2$|$1$||在$Y$末尾补$Y_{i+1} = 0$|$Y_{i+1}-Y_{i}$|$n+1$|$n$|**最后一次加完不移位**|
|补码两位乘法|$3$|$1$|乘数位为**偶数**,末尾补$0$|在$Y$末尾补$Y_{i+1}=0$|$Y_{i+1},Y_i,Y_{i-1}$|$\lceil\frac{n+1}{2}\rceil$|$\lceil\frac{n+1}{2}\rceil$|**最后一次仅右移$1$位**|
#### 除法

|除法|$X$符号|运算规则|累加|移位|商位数|商符号|重点|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|原码除法|2|够减上1减,不够减上0加;**第一次直接减**|$n$|$n$|$n+1$|异或算|**$X,Y$是绝对值**|
|补码除法|2|同号减, 异号加, **第一次同样**|$n$|$n$|$n+1$|包含在商中||每次求和后更新商|
## 浮点数各种计算
### 浮点数加减法

- 计算步骤：
  - 根据题意将运算数转换为浮点表示。如$6$转换为$0.1100000\times2^3$，$0.3125$转换为$0.1010000\times2^{-1}$
  - **对阶**
    - 右移尾数一次, 阶数加一
  - 尾数**双符号位**相加
  - 判断是否溢出以及规格化

### 浮点数乘除法

- 乘法：
  - 尾数相乘
  - 阶码相加
- 除法：
  - 尾数相除
  - 阶码相减

## BCD码各种计算
### BCD码加法
- 计算步骤：
  - 将十进制数转为BCD码，比如2805转换为$(0010\ 1000\ 0000\ 0101)_{BCD}$
  - 对应位数的BCD码相加，若发现大于9，即$1001$时，则需要修正，加上6，即$0110$
  - 得出结果BCD码，然后转换回十进制结果