[TOC]
# 存储器
## 内存储器
### 分类
- `RAM`
  - 易失
- `ROM`
  - 不易失
### RAM
#### SRAM
- 静态
- 贵
- 掉电后信息消失
#### DRAM
- 动态
- 读操作是破坏性的
- 电荷会消失, 因此需要刷新
#### 刷新
- **集中式刷新**
  - 所有存储矩阵一起刷新
  - 一个系统工作周期刷新所有存储矩阵的**一行**, 假设有$n_{row}$行
  - $$\frac{刷新周期T_f}{系统工作周期T_s} = 系统周期数f, \quad f_{r/w} = f-n_{row}$$
- **分布式刷新**
  - 一次只刷新所有矩阵的一行
  - 每隔$t$进行一次刷新, 则$$t=\frac{T_f}{n_{row}}$$
    - $T_f$为必须的刷新周期
### ROM
- 按照字节访问

### 扩展
#### 寻址空间
- CPU寻址空间
  - $n$位地址总线对应$2^n$的寻址空间
- 存储器空间
  - 在寻址空间中实际链接了存储芯片的空间
- 芯片空间
  - 一个芯片容纳的存储单元的地址数量
#### 芯片
$$\phi K \times \psi $$
- $\phi$为芯片空间, 即$n$为地址, 能够对应$0\sim 2^n-1$共$2^n$的地址空间, 每一个地址空间对应一个**字节**
- 因此有$$\phi = \frac{2^n}{2^{10}}$$
  - $16K\implies A_{13}\cdots A_{0}$
  - $64K\implies A_{15}\cdots A_0$
- $\psi$为该芯片的**数据端输出位数**, 是**给定**的
#### 位扩展
- 对**字长**进行扩展, 以两个芯片为例
- 将**地址线, 片选端, 读写控制端**进行**并联**
  - 一个芯片存低位数据, 另一个存高位数据
  - 因为两个芯片同时被选中(读/写), 根据相同的地址一个去找低位数据, 另一个去找高位数据, 才能达到将$\psi$扩展为$m\psi$的目的
#### 字拓展
- 对**存储器中字的数量(存储容量)** 进行扩展
- 将**地址线, 读写控制端**进行**并联**, 片选端来控制读写某一个芯片
  - 将数据分布地存放在不同的芯片里, 相当于给芯片扩充了容量
#### 字位扩展
- 就同时进行字扩展和位扩展

#### 译码方案
- **根据芯片的容量设计译码方案, 搞清楚前因后果**
- 直接译码(没有译码器)
  - 直接把地址线的高位接在片选端
  - 多出的多位地址线必须大于等于要选择的芯片数
- 译码器
  - 将多出的高位地址作为输入, 进入译码器
  - 提供$2^n$种译码结果, 可以在里面选需要的个数
-  **芯片容量不统一时**
   - 以小容量芯片作为片选单位
     - **大容量芯片用选择端的多个地址线逻辑$\&$后共同选择**
       - 因为片选端是**低电平有效**, 所以是**逻辑与**
   - 以大容量芯片作为片选单位
     - **小容量芯片用选择端的某个地址线和低位的某个地址线逻辑运算后共同选择**
## Cache
### 基本概念
主存和`CPU`之间的高速存储器, 全部功能由硬件实现
### 分块
- 假设地址为$n$位, 则主存最多有$2^n$个字节； 将其分为$M$块, 一块中有$B$个字节, 则
$$2^b = B\quad 2^m = M\\\implies 2^{m+b} =M*B =  2^n$$
  - $m$位是**块地址**
  - $b$位是**块内偏移量**
- `cache`也有相同大小($B$字节)的块组成, 一般有$2^c\ll M$块
### 替换
- **标志替换**
  - 直接向cache写入, 修改的字块从cache中替换出来后再写入主存
- **通过式写**
  - 同时向主存和cache写入
#### 替换算法
  - **FIFO**
    - 替换先进入cache的存储块
  - **LRU**
    - 替换近期最少使用的存储块
### 存取时间
- 设cache的存取时间为$t_c$, 命中率为$h$, 主存的存取时间为$t_m$, 则平均存取时间$$t=h*t_c + (1-h)*(t_m+t_c)$$
### 地址映像
- 根据主存的地址访问cache
#### 直接映像
- **第$0,2^c,2^{c+1},\cdots,2^{m-1}$共$\frac{2^{m-1}}{2^c}+1 = m-c = t$块主存都只能映射到第$0$块cache**, 以此类推
- **通过$t = m-c$位的**标记位**判断到底是哪一块**, 即判断这一块cache的标记位和当前主存地址的标记位为是否相同
- 过于死板
#### 全相连映像
- 相当于是把主存克隆到cache中, 一个主存地址要与所有cache中的地址对比, 才能得到结果
- $m$位标志位, $b$位块内地址, 和主存相同
- 效率低下, 成本高昂
#### 组相连映像
- **把cache再分块**, 分为$2^{c'}$块, 每一块包含$2^{r}$个存储块, 有$$c = c'+r\implies 2^c = 2^{c'}*2^r$$
- 对于编号为$i, 0\leq i\leq 2^m-1$的主存块, 其对应在cache中的存储块序号为$$j=(i \ mod\ 2^{c'})*2^r+k\quad 0\leq j\leq 2^c-1, 0\leq k\leq2^r-1 $$
  - 对于一个主存地址, 只需要将其对应到**cache块**中, 然后最多比较$2^r$个**存储块**即可
- 第$0,2^{c'},2^{c'+1},\cdots,2^{m-1}$共$\frac{2^{m-1}}{2^{c'}}+1 = m-c'$块主存都映射到第$0$个**cache块**, 然后在这个**cache块**中检查每一个**存储块**的标志位
  - 标志位数为$m-c'=t+r$
- 增强了映像的灵活性, 牺牲了一部分性能
## 外存储器

### 平均等待时间
$$t=\frac{60}{RPM}\quad s$$
- $RPM$为每分钟旋转圈数
### 柱面数
$$c = \frac{d_o-d_i}{2}*\rho_p$$
- $d_o$为外径, $d_i$为内径($cm$)
- $\rho_p$为道密度($道/cm$)
### 总容量
$$Capacity=m*C*\rho_b*c$$
- $m$为盘面数
- $C$为某一磁道周长
- $\rho_b$为对应磁道位密度
- $c$为柱面数
### 内部传输速率
$$p = \frac{RPM}{60}*C*\rho_b\quad (bit/s)$$
- $RPM$为每分钟旋转圈数
- $C$为某磁道周长(单位$cm$)
- $\rho_b$为对应磁道位密度(单位$bit/cm$)